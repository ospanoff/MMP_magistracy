import numpy as np


def cg(matvec, b, x0, tol=1e-4, max_iter=None, disp=False, trace=False):
    """
    Метод сопряженных градиентов для решения системы линейных уравнений Ax = b

    Параметры:
    ----------
    matvec: callable matvec(x)
        Функция умножения матрицы системы на произвольный вектор x
        Принимает:
            x: np.ndarray
                Вектор размера n
        Возвращает:
            ax: np.ndarray
                Произведение матрицы системы на вектор x, вектор размера n
    b: np.ndarray
        Правая часть системы, вектор размера n

    x0: np.ndarray
        Начальная точка, вектор размера n

    tol: float, опционально
        Точность по l_∞-норме невязки: norm(A x_k - b, infty) <= tol

    max_iter: int или None, опционально
        Максимальное число итераций метода. Если None, то положить равным n

    disp: bool, опционально
        Отображать прогресс метода по итерациям (номер итерации, текущая
        норма невязки и пр.) или нет

    trace: bool, опционально
        Сохранять траекторию метода для возврата истории или нет

    Возврат:
    --------
    x_sol: np.ndarray
        Найденное решение системы, вектор размера n

    status: int
        Статус выхода, число:
            0: решение найдено с заданной точностью tol
            1: достигнуто максимальное число итераций

    hist: dict, возвращается только если trace=True
        История процесса оптимизации по итерациям. Словарь со следующими
        полями:
            norm_r: np.ndarray
                Норма невязки ||Ax_k − b||_∞ по итерациям

    """
    disp_dig = int(np.fabs(np.log10(tol))) + 1
    status = 1

    g = matvec(x0) - b
    d = -g
    u = matvec(d)

    hist = {'norm_r': [g.max()]}

    norm = np.dot(g, g)

    for k in range(b.size if max_iter is None else max_iter):
        alpha = norm / np.dot(d, u)

        x0 += alpha * d
        g += alpha * u

        norm_new = np.dot(g, g)

        beta = norm_new / norm

        d = -g + beta * d
        u = matvec(d)

        norm = norm_new

        if disp:
            tpl = "iter. #{iter}:\t||r||={norm: .{tol}f}\t"
            print(tpl.format(iter=k, norm=g.max(), tol=disp_dig))

        if trace:
            hist['norm_r'] += [g.max()]

        if norm < tol:
            status = 0
            break

    if trace:
        hist['norm_r'] = np.array(hist['norm_r'])

        return (
            x0,
            status,
            hist
        )

    else:
        return (
            x0,
            status
        )


def ncg(func, x0, tol=1e-4, max_iter=500, c1=1e-4, c2=0.1, disp=False,
        trace=False):
    """
    Нелинейный метод сопряженных градиентов

    Параметры:
    ----------
    func: callable func(x)
        Оракул минимизируемой функции
        Принимает:
            x: np.ndarray
                Точка вычисления, вектора размера n
        Возвращает:
            f: float
                Значение функции в точке x
            g: np.ndarray
                Градиент функции в точке x, вектора размера n

    x0: np.ndarray
        Начальная точка, вектор размера n

    tol: float, опционально
        Точность по l_∞-норме градиента: norm(nabla f(x_k), infty) < tol

    max_iter: int, опционально
        Максимальное число итераций метода

    c1: float, опционально
        Значение константы c1 в условиях Вульфа

    c2: float, опционально
        Значение константы c2 в условиях Вульфа

    disp: bool, опционально
        Отображать прогресс метода по итерациям (номер итерации, число
        вызовов оракула, значение функции, норма градиента и пр.) или нет

    trace: bool, опционально
        Сохранять траекторию метода для возврата истории или нет

    Возврат:
    --------
    x_min: np.ndarray
        Найденная точка минимума, вектор размера n

    f_min: float
        Значение функции в точке x_min

    status: int
        Статус выхода, число:
            0: решение найдено с заданной точностью tol
            1: достигнуто максимальное число итераций или вызовов оракула

    hist: dict, возвращается только если trace=True
        История процесса оптимизации по итерациям. Словарь со следующими
        полями:
            f: np.ndarray
                Значение функции
            norm_g: np.ndarray
                l_∞-норма градиента
            n_evals: np.ndarray
                Суммарное число вызовов оракула на текущий момент
            elaps_t: np.ndarray
                Реальное время, пройденное с начала оптимизации

    """


def lbfgs_compute_dir(sy_hist, g):
    """
    (L-BFGS) Процедура нахождения направления dk

    Параметры:
    ----------
    sy_hist: collections.deque
        История Hk, структура данных «дек». Каждый элемент sy_hist[-i]
        (т. е. i-й справа) -- это пара (s_k−i, y_k−i) из двух элементов
        типа np.ndarray размера n

    g: np.ndarray
        Градиент grad(f(xk)) в текущей точке xk, n-мерный вектор

    Возврат:
    --------
    d: np.ndarray
        Направление спуска метода L-BFGS, вектор размера n

    """


def lbfgs(func, x0, tol=1e-4, max_iter=500, c1=1e-4, c2=0.9, m=10, disp=False,
          trace=False):
    """
    Метод LBFGS

    Параметры:
    ----------
    func: callable func(x)
        Оракул минимизируемой функции
        Принимает:
            x: np.ndarray
                Точка вычисления, вектора размера n
        Возвращает:
            f: float
                Значение функции в точке x
            g: np.ndarray
                Градиент функции в точке x, вектора размера n

    x0: np.ndarray
        Начальная точка, вектор размера n

    tol: float, опционально
        Точность по l_∞-норме градиента: norm(nabla f(x_k), infty) < tol

    max_iter: int, опционально
        Максимальное число итераций метода

    c1: float, опционально
        Значение константы c1 в условиях Вульфа

    c2: float, опционально
        Значение константы c2 в условиях Вульфа

    m: int, опционально
        параметр, указывающий размер истории, используемой методом
        (т.е. число хранимых пар (s_k, y_k))

    disp: bool, опционально
        Отображать прогресс метода по итерациям (номер итерации, число
        вызовов оракула, значение функции, норма градиента и пр.) или нет

    trace: bool, опционально
        Сохранять траекторию метода для возврата истории или нет

    Возврат:
    --------
    x_min: np.ndarray
        Найденная точка минимума, вектор размера n

    f_min: float
        Значение функции в точке x_min

    status: int
        Статус выхода, число:
            0: решение найдено с заданной точностью tol
            1: достигнуто максимальное число итераций или вызовов оракула

    hist: dict, возвращается только если trace=True
        История процесса оптимизации по итерациям. Словарь со следующими
        полями:
            f: np.ndarray
                Значение функции
            norm_g: np.ndarray
                l_∞-норма градиента
            n_evals: np.ndarray
                Суммарное число вызовов оракула на текущий момент
            elaps_t: np.ndarray
                Реальное время, пройденное с начала оптимизации

    """


def hfn(func, x0, hess_vec, tol=1e-4, max_iter=500, c1=1e-4, c2=0.9,
        disp=False, trace=False):
    """
    Неточный метод Ньютона

    Параметры:
    ----------
    func: callable func(x)
        Оракул минимизируемой функции
            Принимает:
                x: np.ndarray
                    Точка вычисления, вектор размера n
            Возвращает:
                f: float
                    Значение функции в точке x
                g: np.ndarray
                    Градиент функции в точке x, вектор размера n

    x0: np.ndarray
        Начальная точка, вектор размера n

    hess_vec: callable hess_vec(x, v)
        Функция умножения гессиана (или его аппроксимации) в точке x на
        произвольный вектор v
        Принимает:
            x: np.ndarray
                Точка вычисления, вектор размера n
            v: np.ndarray
                Вектор для умножения размера n
        Возвращает:
            hv: np.ndarray
                Произведение гессиана на вектор v, вектор размера n
            tol: float, опционально
                Точность по l_∞-норме градиента:
                norm(nabla f(x_k), infty) < tol

    max_iter: int, опционально
        Максимальное число итераций метода

    c1: float, опционально
        Значение константы c1 в условиях Вульфа

    c2: float, опционально
        Значение константы c2 в условиях Вульфа

    disp: bool, опционально
        Отображать прогресс метода по итерациям (номер итерации, число
        вызовов оракула, значение функции, норма градиента и пр.) или нет

    trace: bool, опционально
        Сохранять траекторию метода для возврата истории или нет

    Возврат:
    --------
    x_min: np.ndarray
        Найденная точка минимума, вектор размера n

    f_min: float
        Значение функции в точке x_min

    status: int
        Статус выхода, число:
            0: решение найдено с заданной точностью tol
            1: достигнуто максимальное число итераций

    hist: dict, возвращается только если trace=True
        История процесса оптимизации по итерациям. Словарь со следующими
        полями:
            f: np.ndarray
                Значение функции
            norm_g: np.ndarray
                l_∞-норма градиента
            n_evals: np.ndarray
                Суммарное число вызовов оракула (сумма func и hess_vec) на
                текущий момент
            elaps_t: np.ndarray
                Реальное время, пройденное с начала оптимизации

        """
